.TH "hconverter.h" 3 "Tue Jan 5 2016" "hconverter" \" -*- nroff -*-
.ad l
.nh
.SH NAME
hconverter.h \- 
.SH "Public header file for hconverter library\&. "
.PP
 

.SH SYNOPSIS
.br
.PP
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBhc_date_s\fP"
.br
.ti -1c
.RI "struct \fBheb_time_s\fP"
.br
.RI "\fIHebrew time: hour and parts\&. \fP"
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef enum \fBhc_day_of_week\fP \fBhc_day_of_week\fP"
.br
.ti -1c
.RI "typedef enum \fBhc_calendar_type\fP \fBhc_calendar_type\fP"
.br
.RI "\fISupported types of calendar\&. \fP"
.ti -1c
.RI "typedef struct \fBhc_date_s\fP \fBhc_date\fP"
.br
.ti -1c
.RI "typedef struct \fBheb_time_s\fP \fBheb_time\fP"
.br
.RI "\fIHebrew time: hour and parts\&. \fP"
.ti -1c
.RI "typedef enum \fBheb_year_type\fP \fBheb_year_type\fP"
.br
.RI "\fIenum of possible layouts of the variable length Hebrew months Cheshvan and Kislev in a given year\&. \fP"
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBhc_day_of_week\fP { \fBSUNDAY\fP, \fBMONDAY\fP, \fBTUESDAY\fP, \fBWEDNESDAY\fP, \fBTHURSDAY\fP, \fBFRIDAY\fP, \fBSATURDAY\fP }"
.br
.ti -1c
.RI "enum \fBhc_calendar_type\fP { \fBNONE\fP, \fBGREGORIAN\fP, \fBJULIAN\fP, \fBHEBREW\fP }
.RI "\fISupported types of calendar\&. \fP""
.br
.ti -1c
.RI "enum \fBheb_year_type\fP { \fBSHORT_HEB_YEAR\fP, \fBNORMAL_HEB_YEAR\fP, \fBFULL_HEB_YEAR\fP }
.RI "\fIenum of possible layouts of the variable length Hebrew months Cheshvan and Kislev in a given year\&. \fP""
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBset_hc_date\fP (\fBhc_date\fP *, int year, int month, int day, \fBhc_calendar_type\fP)"
.br
.ti -1c
.RI "int \fBhc_convert\fP (\fBhc_date\fP *date, \fBhc_calendar_type\fP target_calendar)"
.br
.RI "\fIThis function converts a date from one calendar to another\&. \fP"
.ti -1c
.RI "int \fBhc_check\fP (\fBhc_date\fP *date)"
.br
.RI "\fICheck validity of data in \fBhc_date\fP\&. \fP"
.ti -1c
.RI "int \fBhc_is_leap_year\fP (int year, \fBhc_calendar_type\fP calendar_type)"
.br
.RI "\fICheck if year is leap in given calendar\&. \fP"
.ti -1c
.RI "\fBhc_day_of_week\fP \fBhc_get_day_of_week\fP (\fBhc_date\fP *date)"
.br
.RI "\fIFunction to get day of week out of a \fBhc_date\fP\&. \fP"
.ti -1c
.RI "int \fBhc_get_month_length\fP (int year, int month, \fBhc_calendar_type\fP calendar_type)"
.br
.RI "\fIFunction to get the length of a month\&. \fP"
.ti -1c
.RI "int \fBhc_compute_keviut\fP (const int year, int *rosh_hashana_dow, int *pesach_dow, int *ck, int *leap)"
.br
.RI "\fICompute year 'keviut' and put the result into 4 integers\&. \fP"
.ti -1c
.RI "int \fBhc_set_hc_heb_time\fP (\fBheb_time\fP *time, int hour, int part)"
.br
.RI "\fIConvenience method to set ::hc_heb_time struct value\&. \fP"
.ti -1c
.RI "int \fBhc_compute_molad_rosh_hashana\fP (int year, \fBhc_calendar_type\fP cal_type, \fBhc_date\fP *date, \fBheb_time\fP *time)"
.br
.RI "\fICompute the date time of molad of Rosh Hashana for given year\&. \fP"
.ti -1c
.RI "int \fBhc_compute_molad\fP (const int year, int month, const \fBhc_calendar_type\fP cal_type, \fBhc_date\fP *date, \fBheb_time\fP *time)"
.br
.RI "\fICompute the date and time of molad (new moon according to the Hebrew calendar) for given year and month\&. \fP"
.ti -1c
.RI "\fBheb_year_type\fP \fBhc_get_heb_year_type\fP (int year)"
.br
.RI "\fICompute number of days in excess of 58 in Cheshvan and Kislev combined\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 

.SH "Public header file for hconverter library\&. "
.PP



.PP
\fBDate:\fP
.RS 4
Dec 29, 1998 
.RE
.PP
\fBAuthor:\fP
.RS 4
Isaac Mushinsky
.RE
.PP
Contains all functional offerings of this library: convert dates between Hebrew, Gregorian and Julian calendars as well as compute certain specific times for the new moon, types of Jewish year\&.
.PP
.SS "Note about Hebrew month ordering\&. "
.PP
Although each Hebrew year starts with the month of Tishrei, Tishrei is not the first in the order of months\&. There are a couple of reasons for this\&. Nisan is called the 'first month' in the Torah for most purposes\&. Also, on a Hebrew leap year the 13th month (adar 2) is added before Nisan, not before Tishrei\&. This makes it more convenient to senumerate months not in chronological order but rather starting from Nisan to the end of year (Elul), and then returning to Tishrei through Adar\&. Thus the Hebrew months here are represented by integers as follows:
.PP
.PD 0
.IP "\(bu" 2
\fCTishrei\fP 7 
.IP "\(bu" 2
\fCCheshvan\fP 8 
.IP "\(bu" 2
\fCKislev\fP 9 
.IP "\(bu" 2
\fCTeveth\fP 10 
.IP "\(bu" 2
\fCShvat\fP 11 
.IP "\(bu" 2
\fCAdar\fP 12 (also Adar I on leap years) 
.IP "\(bu" 2
\fCAdar\fP II 13 (only on Hebrew leap years) 
.IP "\(bu" 2
\fCNisan\fP 1 
.IP "\(bu" 2
\fCIyar\fP 2 
.IP "\(bu" 2
\fCSivan\fP 3 
.IP "\(bu" 2
\fCTamuz\fP 4 
.IP "\(bu" 2
\fCMenachem\fP Av 5 
.IP "\(bu" 2
\fCElul\fP 6
.PP
so despite a lower month index, Nisan follows \fBafter\fP Adar\&. For example, the date 5776-01-01 follows 5776-13-29 in yyyy-mm-dd notation\&.
.PP
.SS "Note about keviut "
.PP
Keviut determines layout of the Jewish year, including all holidays and readings of the Torah\&. It is customary to abbreviate it to 4 parameters:
.PP
.PD 0
.IP "\(bu" 2
\fB1\fP day of week of Rosh Hashana, i\&.e\&. the 'new year', Tishrei 1 
.IP "\(bu" 2
\fB2\fP day of week of first day of Pesach, i\&.e\&. Nisan 15 
.IP "\(bu" 2
\fB3\fP combined length of Cheshvan and Kislev (see #hc_heb_year_type) 
.IP "\(bu" 2
\fB4\fP whether or not the year is leap
.PP
Only 14 combinations of these are actually possible\&. 
.SH "Typedef Documentation"
.PP 
.SS "typedef enum \fBhc_calendar_type\fP  \fBhc_calendar_type\fP"

.PP
Supported types of calendar\&. 
.PD 0

.IP "\(bu" 2
GREGORIAN 
.IP "\(bu" 2
JULIAN 
.IP "\(bu" 2
HEBREW 
.PP

.SS "typedef struct \fBhc_date_s\fP  \fBhc_date\fP"
Structure representing a date\&. 
.SS "typedef enum \fBhc_day_of_week\fP  \fBhc_day_of_week\fP"
Convenience enum for days of week: \fISUNDAY=0, MONDAY=1, \&.\&.\&., FRIDAY=6\fP 
.SS "typedef struct \fBheb_time_s\fP  \fBheb_time\fP"

.PP
Hebrew time: hour and parts\&. This type is specific to Hebrew calendar\&. Time is measured in hours and chalokim ('parts'), which are 1/1080 of an hour\&. 
.SS "typedef enum \fBheb_year_type\fP  \fBheb_year_type\fP"

.PP
enum of possible layouts of the variable length Hebrew months Cheshvan and Kislev in a given year\&. 
.PD 0

.IP "\(bu" 2
SHORT_HEB_YEAR means that both Cheshvan and Kislev are 29 days long 
.IP "\(bu" 2
NORMAL_HEB_YEAR means 29 days in Cheshvan and 30 days in Kislev 
.IP "\(bu" 2
FULL_HEB_YEAR means that both months are 30 days long 
.PP

.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBhc_calendar_type\fP"

.PP
Supported types of calendar\&. 
.PD 0

.IP "\(bu" 2
GREGORIAN 
.IP "\(bu" 2
JULIAN 
.IP "\(bu" 2
HEBREW 
.PP

.SS "enum \fBhc_day_of_week\fP"
Convenience enum for days of week: \fISUNDAY=0, MONDAY=1, \&.\&.\&., FRIDAY=6\fP 
.SS "enum \fBheb_year_type\fP"

.PP
enum of possible layouts of the variable length Hebrew months Cheshvan and Kislev in a given year\&. 
.PD 0

.IP "\(bu" 2
SHORT_HEB_YEAR means that both Cheshvan and Kislev are 29 days long 
.IP "\(bu" 2
NORMAL_HEB_YEAR means 29 days in Cheshvan and 30 days in Kislev 
.IP "\(bu" 2
FULL_HEB_YEAR means that both months are 30 days long 
.PP

.SH "Function Documentation"
.PP 
.SS "int hc_check (\fBhc_date\fP * date)"

.PP
Check validity of data in \fBhc_date\fP\&. Returns 1 if the date is valid, 0 if the date is invalid in corresponding calendar\&. The following are invalid: nonpositive Hebrew year, month less than 1 or more than number of months in given year, day less than one or more than days in month\&.
.PP
\fBParameters:\fP
.RS 4
\fIdate\fP an \fBhc_date\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
0 if invalid, 1 otherwise\&. 
.RE
.PP

.SS "int hc_compute_keviut (const int year, int * rosh_hashana_dow, int * pesach_dow, int * ck, int * leap)"

.PP
Compute year 'keviut' and put the result into 4 integers\&. Keviut determines layout of the Jewish year, including all holidays and readings of the Torah\&. See \fBkeviut\fP for more information\&. Here, we output the 'keviut' parameters by setting values of 4 integers whose pointers are supplied with parameters\&. For any of these output parameters, null pointers are allowed and will be ignored, so users can pass NULL rather than allocate integers for output that they do not need\&.
.PP
\fBParameters:\fP
.RS 4
\fIyear\fP Hebrew year 
.br
\fIrosh_hashana_dow\fP Day of week for Eosh Hashana (1 Tishrei) 
.br
\fIpesach_dow\fP Day of week for Pesach (0 = saturday) 
.br
\fIck\fP returns 0, 1, 2 (SHORT, REGULAR, FULL) for number of days in excess of 58 in Chesh=van and Kislev combined\&. (see #hc_heb_year_type) 
.br
\fIit\fP will return 1 for leap years and 0 otherwise 
.RE
.PP

.SS "int hc_compute_molad (const int year, int month, const \fBhc_calendar_type\fP cal_type, \fBhc_date\fP * date, \fBheb_time\fP * time)"

.PP
Compute the date and time of molad (new moon according to the Hebrew calendar) for given year and month\&. Output parameters are \fBhc_date\fP and ::hc_time objects, passed in to be populated\&. No New memory is allocated\&.
.PP
\fBParameters:\fP
.RS 4
\fIyear\fP 
.br
\fImonth\fP 
.br
\fIhc_calendar_type\fP GREGORINA, JULIAN or HEBREW 
.br
\fIdate\fP pointer to \fBhc_date\fP struct to store result 
.br
\fItime\fP pointer to hc_heb_time to store time result 
.RE
.PP

.SS "int hc_compute_molad_rosh_hashana (int year, \fBhc_calendar_type\fP cal_type, \fBhc_date\fP * date, \fBheb_time\fP * time)"

.PP
Compute the date time of molad of Rosh Hashana for given year\&. This is equivalent to <hc_compute_molad> with month set to 7 (Tishrei)\&.
.PP
The output params \fBhc_date\fP and ::hc_time objects are passed in to be populated\&. 
.PP
\fBParameters:\fP
.RS 4
\fIyear\fP 
.br
\fIhc_calendar_type\fP GREGORINA, JULIAN or HEBREW 
.br
\fIdate\fP pointer to \fBhc_date\fP struct to store result 
.br
\fItime\fP pointer to hc_heb_time to store time result 
.RE
.PP

.SS "int hc_convert (\fBhc_date\fP * date, \fBhc_calendar_type\fP target_calendar)"

.PP
This function converts a date from one calendar to another\&. The given \fBhc_date\fP structure is modified during this call, so no new memory is allocated here\&.
.PP
\fBParameters:\fP
.RS 4
\fIdate\fP This object will be modified so that it has the target \fBhc_calendar_type\fP set along with corresponding date\&. 
.br
\fItarget_calendar\fP see \fBhc_calendar_type\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, -1 if the input date is invalid\&. 
.RE
.PP

.SS "\fBhc_day_of_week\fP hc_get_day_of_week (\fBhc_date\fP * date)"

.PP
Function to get day of week out of a \fBhc_date\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdate\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
a #hc_day of week: 0 for Saturday, 1 for Sunday, \&.\&.\&., 6 for Friday 
.RE
.PP

.SS "\fBheb_year_type\fP hc_get_heb_year_type (int year)"

.PP
Compute number of days in excess of 58 in Cheshvan and Kislev combined\&. 
.PP
\fBParameters:\fP
.RS 4
\fIyear\fP Hebrew year >=1 
.RE
.PP
\fBReturns:\fP
.RS 4
can take 3 values: 
.PD 0

.IP "\(bu" 2
\fBSHORT_HEB_YEAR (0)\fP - both Cheshvan and Kislev 29 days long 
.IP "\(bu" 2
\fBNORMAL_HEB_YEAR (1)\fP - 29 days in Cheshvan, 30 days in Kislev 
.IP "\(bu" 2
\fBFULL _HEB_YEAR (2)\fP - 30 days in both Cheshvan and Kislev 
.PP
.RE
.PP

.SS "int hc_get_month_length (int year, int month, \fBhc_calendar_type\fP calendar_type)"

.PP
Function to get the length of a month\&. 
.PP
\fBParameters:\fP
.RS 4
\fIyear\fP 
.br
\fImonth\&.\fP For Hebrew, see (\fBnote\fP) about the special month order\&. 
.br
\fIcalendar_type\fP see \fBhc_calendar_type\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
length of month in days 
.RE
.PP

.SS "int hc_is_leap_year (int year, \fBhc_calendar_type\fP calendar_type)"

.PP
Check if year is leap in given calendar\&. For Gregorian or Julian calendar this means that length of the year is 366 days\&. In Hebrew calendar it means that the year has 13 months instead of 12\&.
.PP
\fBParameters:\fP
.RS 4
\fIyear\fP Hebrew year >=1 
.br
\fIcalendar_type\fP see \fBhc_calendar_type\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
1 for leap year, 0 for non-leap year 
.RE
.PP

.SS "int hc_set_hc_heb_time (\fBheb_time\fP * time, int hour, int part)"

.PP
Convenience method to set ::hc_heb_time struct value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIparam[out]\fP time 
.br
\fIparam[in]\fP hour 
.br
\fIparam[in]\fP part 
.RE
.PP

.SS "int set_hc_date (\fBhc_date\fP *, int year, int month, int day, \fBhc_calendar_type\fP)"
Convenience method to set the entire \fBhc_date\fP in one call\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdate\fP pointer to \fBhc_date\fP structure 
.br
\fIyear\fP 
.br
\fImonth\fP 
.br
\fIday\fP 
.br
\fIcalendar_type\fP 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for hconverter from the source code\&.
